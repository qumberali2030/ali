# -*- coding: utf-8 -*-
"""pipeline_helpers.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D22jcEAke0KOepu2CSEobhEgkbVcuw7r
"""

# pipeline_helpers.py
# -------------------------------------------------------------
# All custom transformers and pipeline utilities used in model
# -------------------------------------------------------------

import re
import pandas as pd
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.preprocessing import RobustScaler, LabelEncoder
from sklearn.pipeline import Pipeline
from xgboost import XGBClassifier


# -------------------------------------------------------------
# ðŸ“Œ CBC Column Mapper
# -------------------------------------------------------------
class CBCColumnMapper(BaseEstimator, TransformerMixin):
    """
    Exact-match column mapper that handles whitespace and case,
    preventing MCH â†’ MCHC mis-mapping.
    """
    def __init__(self):
        self.standard_columns = ['HB', 'RBC', 'HCT', 'MCV', 'MCH', 'RDW', 'MCHC']
        self.possible_names = {
            'HB':   ['HB', 'HGB', 'HEMOGLOBIN'],
            'RBC':  ['RBC', 'REDBLOOD', 'REDBLOODCELL'],
            'HCT':  ['HCT', 'HEMATOCRIT', 'PCV'],
            'MCV':  ['MCV', 'MEANCORPUSCULARVOLUME'],
            'MCH':  ['MCH', 'MEANCORPUSCULARHEMOGLOBIN'],
            'MCHC': ['MCHC', 'MEANCORPUSCULARHEMOGLOBINCONCENTRATION'],
            'RDW':  ['RDW', 'REDCELLDISTRIBUTIONWIDTH']
        }
        self.column_mapping = {}

    def clean_column_name(self, col):
        return re.sub(r'[^A-Z0-9]', '', str(col).strip().upper())

    def fit(self, X, y=None):
        cleaned_cols = {self.clean_column_name(c): c for c in X.columns}

        for std in self.standard_columns:
            found = None
            for pattern in self.possible_names[std]:
                pat = self.clean_column_name(pattern)
                if pat in cleaned_cols and cleaned_cols[pat] not in self.column_mapping:
                    found = cleaned_cols[pat]
                    break
            if found:
                self.column_mapping[found] = std
            else:
                print(f"âš ï¸ Warning: could not find column for '{std}'")

        print("ðŸ“‹ Column mapping:", self.column_mapping)
        return self

    def transform(self, X):
        X2 = X.rename(columns=self.column_mapping)
        missing = [c for c in self.standard_columns if c not in X2.columns]
        if missing:
            raise KeyError(f"âŒ Missing required columns after mapping: {missing}")

        return X2[self.standard_columns]


# -------------------------------------------------------------
# ðŸ“Œ CBC Domain Cleaner
# -------------------------------------------------------------
class CBCDomainCleaner(BaseEstimator, TransformerMixin):
    """
    Clean CBC data by removing biologically implausible values.
    """
    def __init__(self, domain_ranges=None):
        if domain_ranges is None:
            self.domain_ranges = {
                'HB': (3, 25),
                'RBC': (1.5, 8),
                'HCT': (10, 70),
                'MCV': (40, 130),
                'MCH': (8, 45),
                'RDW': (5, 30),
                'MCHC': (20, 40)
            }
        else:
            self.domain_ranges = domain_ranges

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X_clean = X.copy()
        original_count = len(X_clean)

        for col, (min_val, max_val) in self.domain_ranges.items():
            if col in X_clean.columns:
                mask = (X_clean[col] >= min_val) & (X_clean[col] <= max_val)
                X_clean = X_clean[mask]

        removed_count = original_count - len(X_clean)
        if removed_count > 0:
            print(f"ðŸ§¹ Removed {removed_count} biologically implausible rows")

        return X_clean.reset_index(drop=True)


# -------------------------------------------------------------
# ðŸ“Œ Diagnostic Index Calculator
# -------------------------------------------------------------
class DiagnosticIndexCalculator(BaseEstimator, TransformerMixin):
    """
    Calculate diagnostic indices for Thalassemia screening.
    """
    def fit(self, X, y=None):
        return self

    def transform(self, X):
        X_indices = X.copy()

        X_indices['Mentzer'] = X['MCV'] / X['RBC']
        X_indices['ShineLal'] = (X['MCV']**2 * X['MCH']) / 100
        X_indices['Ehsani'] = X['MCV'] - (10 * X['RBC'])
        X_indices['GreenKing'] = (X['MCV']**2 * X['RDW']) / (X['HB'] * 100)
        X_indices['Srivastava'] = X['MCH'] / X['RBC']

        print("ðŸ§¬ Diagnostic indices calculated.")
        return X_indices


# -------------------------------------------------------------
# ðŸ“Œ Target Processor
# -------------------------------------------------------------
class TargetProcessor:
    """
    Handle target variable encoding.
    """
    def __init__(self):
        self.label_encoder = LabelEncoder()
        self.fitted = False

    def fit_transform(self, y):
        if y.dtype == 'object':
            y_encoded = self.label_encoder.fit_transform(y)
        else:
            y_encoded = y.values

        self.fitted = True
        print("ðŸŽ¯ Target encoding complete:", np.unique(y_encoded))
        return y_encoded

    def transform(self, y):
        if not self.fitted:
            raise ValueError("TargetProcessor must be fitted first")

        if y.dtype == 'object':
            return self.label_encoder.transform(y)
        return y.values


# -------------------------------------------------------------
# ðŸ“Œ Create Full CBC Pipeline
# -------------------------------------------------------------
def create_cbc_pipeline():
    preprocessor = Pipeline(steps=[
        ('cleaner', CBCDomainCleaner()),
        ('index_calc', DiagnosticIndexCalculator()),
        ('scaler', RobustScaler())
    ])

    model_pipeline = Pipeline(steps=[
        ('preprocess', preprocessor),
        ('classifier', XGBClassifier(
            use_label_encoder=False,
            eval_metric='logloss',
            random_state=42
        ))
    ])

    return model_pipeline